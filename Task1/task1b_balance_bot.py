import time
    
def sysCall_init():
 
    sim = require('sim')
    print("Simulation initialized")
    global left_motor_handle, right_motor_handle, body_handle, left_wheel_handle, right_wheel_handle
    global start_time, end_time
    global error_integral, error_derivative, previous_error 
 
    left_motor_handle = sim.getObject('/body/left_joint')
    right_motor_handle = sim.getObject('/body/right_joint')
    body_handle = sim.getObject('/body')
    left_wheel_handle = sim.getObject('/body/left_joint/left_wheel')
    right_wheel_handle = sim.getObject('/body/right_joint/right_wheel')
 
    sim.setObjectInt32Param(left_motor_handle, sim.jointintparam_dynctrlmode, sim.jointdynctrl_velocity)
    sim.setObjectInt32Param(right_motor_handle, sim.jointintparam_dynctrlmode, sim.jointdynctrl_velocity)
 
    sim.setJointTargetVelocity(left_motor_handle, 0)
    sim.setJointTargetVelocity(right_motor_handle, 0)
 
    start_time = sim.getSimulationTime()
    end_time = start_time + 30 
 
    error_integral = 0.0
    error_derivative = 0.0
    previous_error = 0.0
 
    # do some initialization here
    # This function will be executed once when the simulation starts
 
    # Instead of using globals, you can do e.g.:
    # self.myVariable = 21000000
 
    ######## ADD YOUR CODE HERE #######
    # Hint: Initialize the scene objects which you will require
    #       Initialize algorithm related variables here
 
    ##################################
 
def sysCall_actuation():
    # put your actuation code here
    # This function will be executed at each simulation time step
 
    ####### ADD YOUR CODE HERE ######
    # Hint: Use the error feedback and apply control algorithm here
    #       Provide the resulting actuation as input to the actuator joint
 
    global left_motor_handle, right_motor_handle, body_orientation, Kp, Ki, Kd, error_integral, error_derivative, previous_error
    global end_time
    global error_integral, error_derivative, previous_error 
 
    Kp = 1200
    Ki = 0.1
    Kd = 2
 
 
    error = sysCall_sensing()
    current_time = sim.getSimulationTime()
    t_l_b = 20 - current_time
    print("20-t = %f" %t_l_b)
    dt = sim.getSimulationTimeStep()
    error_integral += error 
    error_derivative = (error - previous_error) 
    control_signal = Kp * error + Ki * error_integral + Kd * error_derivative * 100
 
    left_velocity = control_signal
    right_velocity = control_signal  
    sim.setJointTargetVelocity(left_motor_handle, left_velocity)
    sim.setJointTargetVelocity(right_motor_handle, right_velocity)
 
    fin_vel_r = sim.getJointTargetVelocity(right_motor_handle)
    #print("velocity right = %f" %fin_vel_r)
    fin_vel_l = sim.getJointTargetVelocity(left_motor_handle)
    #print("velocity left = %f" %fin_vel_l)
    previous_error = error
 
    if sim.getSimulationTime() > end_time:
        sim.stopSimulation()
 
    # Example psuedo code:
    #   x1 = error_state_1; # Error in states w.r.t desired setpoint
    #   x2 = error_state_2;
    #   x3 = error_state_3;
    #   x4 = error_state_4;
    #   k = [gain_1 , gain_1, gain_3, gain_4];      # These gains will be generated by control algorithm. For ex: LQR, PID, etc.
    #   U = -k[1]*x1 +k[2]*x2 -k[3]*x3 +k[4]*x4;    # +/- Sign convention may differ according to implementation
    #   Set_joint_actuation(U);                     # Provide this calculated input to system's actuator
 
    #################################
 
 
def sysCall_sensing():
    # put your sensing code here
    # This function will be executed at each simulation time step
 
    ####### ADD YOUR CODE HERE ######
    global body_position, body_orientation, roll, pitch, yaw
 
    body_position = sim.getObjectPosition(body_handle, -1)
    inc = sim.getObjectOrientation(body_handle, -1)
 
    yaw, pitch, roll = sim.alphaBetaGammaToYawPitchRoll(inc[0], inc[1], inc[2])
 
    set_point = 0
    error = set_point - roll
    print("error = %f" %error)
    return error
 
    # Hint: Take feedback here & do the error calculation
 
    #################################
 
def sysCall_cleanup():
    # do some clean-up here
    # This function will be executed when the simulation ends
    pass
    ####### ADD YOUR CODE HERE ######
    # Any cleanup (if required) to take the scene back to it's original state after simulation
    # It helps in case simulation fails in an unwanted state.
    #################################
 
 
# See the user manual or the available code snippets for additional callback functions and details