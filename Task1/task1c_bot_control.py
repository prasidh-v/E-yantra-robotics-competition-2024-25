import time
 
def sysCall_init():
    sim = require('sim')
 
    # do some initialization here
    # This function will be executed once when the simulation starts
 
    # Instead of using globals, you can do e.g.:
    # self.myVariable = 21000000
 
    ######## ADD YOUR CODE HERE #######
    # Hint: Initialize the scene objects which you will require
    #       Initialize algorithm related variables here
    print("Simulation initialized")
    global left_motor_handle, right_motor_handle, body_handle, left_wheel_handle, right_wheel_handle
    global start_time, end_time
    global error_integral, error_derivative, previous_error 
    global r_w1, wid_w1, x_body, y_body, z_body, omega, domega, dv, v, v_max, v_min, omega_max, omega_min
 
    left_motor_handle = sim.getObject('/body/left_joint')
    right_motor_handle = sim.getObject('/body/right_joint')
    body_handle = sim.getObject('/body')
    left_wheel_handle = sim.getObject('/body/left_joint/left_wheel')
    right_wheel_handle = sim.getObject('/body/right_joint/right_wheel')
 
    sim.setObjectInt32Param(left_motor_handle, sim.jointintparam_dynctrlmode, sim.jointdynctrl_velocity)
    sim.setObjectInt32Param(right_motor_handle, sim.jointintparam_dynctrlmode, sim.jointdynctrl_velocity)
 
    sim.setJointTargetVelocity(left_motor_handle, 0)
    sim.setJointTargetVelocity(right_motor_handle, 0)
 
    start_time = sim.getSimulationTime()
    end_time = start_time + 30 
 
    error_integral = 0.0
    error_derivative = 0.0
    previous_error = 0.0
 
    v_max = 0.15
    v_min = -0.3
    omega_min = -0.1
    omega_max = 0.1
    omega = 0
    v = 0
    ##################################
 
def sysCall_actuation():
    # put your actuation code here
    # This function will be executed at each simulation time step
 
    ####### ADD YOUR CODE HERE ######
    # Hint: Use the error feedback and apply control algorithm here
    #       Provide the resulting actuation as input to the actuator joint
    global left_motor_handle, right_motor_handle, body_orientation, Kp, Ki, Kd, error_integral, error_derivative, previous_error
    global end_time
    global error_integral, error_derivative, previous_error 
    global r_w1, wid_w1, x_body, y_body, z_body, omega, domega, dv, v, v_max, v_min, omega_max, omega_min

 
    Kp = 1200/2
    Ki = 0.3/2
    Kd = 2/2
    

    error, keypress = sysCall_sensing()
    current_time = sim.getSimulationTime()
    t_l_b = 20 - current_time
    #print("20-t = %f" %t_l_b)
    dt = sim.getSimulationTimeStep()
    error_integral += error 
    error_derivative = (error - previous_error) 
    control_signal = Kp * error + Ki * error_integral + Kd * error_derivative * 100
 
    dv = 1.0
    domega = 1.0
 
    if keypress is not None:
        if keypress == 2007: 
            v -= dv
        elif keypress == 2008:  
            v += dv
        elif keypress == 2009:  
            omega -= domega
        elif keypress == 2010:  
            omega += domega
 
    if omega != 0:
            if (omega>omega_max):
                omega = omega_max;
            if (omega<omega_min):
                omega = omega_min
 
    if v != 0:
           if (v>v_max):
               v=v_max
           if (v<v_min):
               v=v_min
 
    print("v = %f" %v)
    print("omega = %f" %omega)
    r = 0.0085 #radius of wheel
    b = 0.07 #half width, width is distance between the wheels
 
    v_drive_l = (v/r)-(omega*b/r)
    v_drive_r = (v/r)+(omega*b/r)
 
    left_velocity = control_signal + v_drive_l
    right_velocity = control_signal + v_drive_r
 
    sim.setJointTargetVelocity(left_motor_handle, left_velocity)
    sim.setJointTargetVelocity(right_motor_handle, right_velocity)
 
    fin_vel_r = sim.getJointTargetVelocity(right_motor_handle)
    #print("velocity right = %f" %fin_vel_r)
    fin_vel_l = sim.getJointTargetVelocity(left_motor_handle)
    #print("velocity left = %f" %fin_vel_l)
    previous_error = error
 
    if sim.getSimulationTime() > end_time:
        sim.stopSimulation()
    # Example psuedo code:
    #   x1 = error_state_1; # Error in states w.r.t desired setpoint
    #   x2 = error_state_2;
    #   x3 = error_state_3;
    #   x4 = error_state_4;
    #   k = [gain_1 , gain_1, gain_3, gain_4];      # These gains will be generated by control algorithm. For ex: LQR, PID, etc.
    #   U = -k[1]*x1 +k[2]*x2 -k[3]*x3 +k[4]*x4;    # +/- Sign convention may differ according to implementation
    #   Set_joint_actuation(U);                     # Provide this calculated input to system's actuator
 
    #################################
 
def sysCall_sensing():
    # put your sensing code here
    # This function will be executed at each simulation time step
 
    ####### ADD YOUR CODE HERE ######
    # Hint: Take feedback here & do the error calculation
    global body_position, body_orientation, roll, pitch, yaw
 
    body_position = sim.getObjectPosition(body_handle, -1)
    inc = sim.getObjectOrientation(body_handle, -1)
 
    yaw, pitch, roll = sim.alphaBetaGammaToYawPitchRoll(inc[0], inc[1], inc[2])
 
    set_point = 0
    error = set_point - roll
    #print("error = %f" %error)
 
    ############### Keyboard Input ##############
    message,data,data2 = sim.getSimulatorMessage()
 
    if (message == sim.message_keypress):
        if data[0] == 2007: 
            return error, 2007
 
        if data[0] == 2008: 
            return error, 2008
 
 
        if data[0] == 2009: 
            return error, 2009
 
 
        if data[0] == 2010: 
            return error, 2010
 
    else:
        print("unrecognized keypress")
        return error, None
 
    #########################################
 
def sysCall_cleanup():
    # do some clean-up here
    # This function will be executed when the simulation ends
 
    ####### ADD YOUR CODE HERE ######
    pass
    # Any cleanup (if required) to take the scene back to it's original state after simulation
    # It helps in case simulation fails in an unwanted state.
    #################################
 
 
# See the user manual or the available code snippets for additional callback functions and details